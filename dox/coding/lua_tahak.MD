# Lua 5.4 tah√°k

(Toto zdaleka nen√≠ ve≈°ker√Ω v√Ωƒçet funkc√≠ a vlastnost√≠ dan√©ho programovac√≠ho jazyka. Jedn√° se pouze o&nbsp;m√© z√°pisky vznikl√© bƒõhem ≈ôe≈°en√≠ [AoC](https://github.com/RDMCz/AdventOfCode) a/nebo studia na V≈†.)

## Kolekce

Lua m√° jedin√Ω typ kolekce zvan√Ω `table`, kter√Ω m≈Ø≈æe slou≈æit jako pole, slovn√≠k, struktura, ... a indexuje jej od jedniƒçky.

### Table jako 1D pole

```lua
-- Tables jsou heterogenn√≠:
local collection = {7, 8, "A"}

-- P≈ôid√°n√≠ prvku:
table.insert(collection, 3, 9) -- parametry: vlo≈æit do jak√© table, volitelnƒõ na jak√Ω index, co vlo≈æit

-- V√Ωpis prvk≈Ø:
print(table.concat(collection, ", ")) --> 7, 8, 9, A

-- Poƒçet prvk≈Ø:
print(#collection) -- Proto≈æe indexujeme od jedniƒçky, poƒçet prvk≈Ø je roven posledn√≠mu indexu

-- Iterace:
for i=1,#collection do -- i iteruje od 1 (exkluzivn√≠) do #collection (exkluzivn√≠)
    print(collection[i])
end
-- nebo
for i,item in ipairs(collection) do
    print(i .. " " .. item)
end

-- IndexOf ‚Äì Lua nem√° indexOf, m≈Ø≈æeme si ho ale pro konkr√©tn√≠ pole jednodu≈°e napsat:
local index_of = {}
for index,value in pairs(collection) do
    index_of[value] = index
end
print(index_of[9])   --> 3
print(index_of["A"]) --> 4
-- ‚áí p≈ôi v√≠ce v√Ωskytech stejn√©ho prvku vrac√≠ index posledn√≠ho v√Ωskytu
```

### Table jako asociativn√≠ pole (dictionary)

```lua
local dict = {["Key1"] = "Value1"}
dict["Key2"] = "Value2"
print(dict["Key1"] .. " " .. dict["Key2"]) --> Value1 Value2
```

V jedn√© table lze kombinovat ‚Äûnorm√°ln√≠‚Äú a ‚Äûslovn√≠kov√©‚Äú polo≈æky:

```lua
local dict = {
    ["Key1"] = "Value1",
    "Item1",
    [2] = "Value2",
    --"Item2", -- Nelze, znamenalo by duplicitn√≠ index
}

print(dict["Key1"]) --> Value1
print(dict[1])      --> Item1
print(dict[2])      --> Value2
print(dict[3])      --> nil
print(dict["ABCD"]) --> nil
```

Pro zji≈°tƒõn√≠ poƒçtu kl√≠ƒç≈Ø ve slovn√≠ku je bohu≈æel nutno iterovat p≈ôes v≈°echny p√°ry a inkrementovat si promƒõnnou.

### Table jako mno≈æina (set)

Mno≈æina je v podstatƒõ slovn√≠k bez hodnot, pou≈æijeme proto slovn√≠k s boolean hodnotami:

```lua
local pseudo_set = {}
pseudo_set["Key1"] = true
if pseudo_set["Key1"] then
    -- Mno≈æina obsahuje Key1
end
```

## ≈òetƒõzce

### Zji≈°tƒõn√≠ indexu pod≈ôetƒõzce

```lua
local text = "1,2,3,(4,5),6,7,(8,9,10),11,(12,13),14"
local start_i, end_i
```

V ≈ôetƒõzci chceme hledat indexy uz√°vorkovan√Ωch dvojic ƒç√≠sel `(ùëë,ùëë)`, ty se zde nach√°zej√≠ na indexech 7‚Äì11 a 29‚Äì35. Pokud n√°s zaj√≠m√° konkr√©tn√≠ dvojice ƒç√≠sel (nap≈ô. `(4,5)`) pou≈æijeme `string.find` n√°sledovnƒõ:

```lua
start_i, end_i = string.find(text, "(4,5)", 1, true)
print(start_i .. ", " .. end_i) --> 7, 11
```

Parametry funkce `string.find` jsou:

1. Kde hledat
2. Co hledat
3. Poƒç√°teƒçn√≠ index (1 znamen√° hled√°n√≠ od zaƒç√°tku stringu)
4. Ignorovat ‚Äûregex‚Äú? (true znamen√°, ≈æe hled√°me p≈ôesnƒõ to, co je uvedeno jako druh√Ω parametr)

Lua nem√° plnohodnotnou podporu regexu, nƒõkter√© v√Ωrazy ale zvl√°d√°. Pro nalezen√≠ indexu libovoln√©ho `(ùëë,ùëë)` zmƒõn√≠me druh√Ω a ƒçtvrt√Ω parametr:

```lua
-- Procento `%` se pou≈æ√≠v√° jako √∫nikov√Ω znak a z√°rove≈à pro z√°pis skupiny znak≈Ø
start_i, end_i = string.find(text, "%(%d+,%d+%)", 1, false)
print(start_i .. ", " .. end_i) --> 7, 11
```

Hled√°n√≠ po prvn√≠m n√°lezu konƒç√≠, jak nal√©zt v≈°echny v√Ωskyty?

```lua
local search_i = 1
while true do
    local searched_start_i, searched_end_i = string.find(text, "%(%d+,%d+%)", search_i, false)
    if searched_start_i == nil then break end
    io.write(searched_start_i .. ", " ..searched_end_i .. "; ") -- 7, 11; 29, 35;
    search_i = searched_end_i + 1
end
io.write("\n")
```

Krat≈°√≠ zp≈Øsob je pou≈æit√≠ `string.gmatch`, kter√Ω slou≈æ√≠ pro hled√°n√≠ v√Ωraz≈Ø (nejen index≈Ø). Ne-escapnut√© z√°vorky ve v√Ωrazu znaƒç√≠ jednotliv√© skupiny, kter√© jsou p≈ôi≈ôazeny do promƒõnn√Ωch. Pokud jsou z√°vorky pr√°zdn√©, vrac√≠ sv≈Øj index. P≈ôid√°n√≠m z√°vorek p≈ôed a za n√°≈° v√Ωraz tedy dost√°v√°me poƒç√°teƒçn√≠ a koncov√Ω index v√Ωrazu. Koncov√Ω index je ale nyn√≠ exkluzivn√≠, nikoliv inkluzivn√≠.

```lua
for start_i, end_i in string.gmatch(text, "()%(%d+,%d+%)()") do
    print(start_i .. ", " .. end_i)
    --> 7, 12
    --> 29, 36
end
```

### Hled√°n√≠ pod≈ôetƒõzc≈Ø podle vzoru

Pou≈æijeme ji≈æ zm√≠nƒõn√© `string.gmatch`:

```lua
for match_value in string.gmatch(text, "%(%d+,%d+%)") do
    print(match_value)
    --> (4,5)
    --> (12,13)
end
```

P≈ôid√°n√≠m skupin lze hledat jak samotn√© v√Ωrazy, tak jejich indexy:

```lua
for start_i, match_value in string.gmatch(text, "()(%(%d+,%d+%))") do
    print("index " .. start_i .. ": " .. match_value)
    --> index 7: (4,5)
    --> index 29: (12,13)
end
```

### String split?

Lua nem√° metodu pro splitov√°n√≠ ≈ôetƒõzce. Pokud chceme splitovat podle znaku / sady znak≈Ø, pou≈æijeme opƒõt `string.gmatch`, kter√© lze v tomto p≈ô√≠padƒõ ch√°pat jako opak splitu. Chceme-li splitovat podle mezery, hled√°me v≈°e, co nen√≠ mezera a m√° libovolnou nenulovou d√©lku:

```lua
local text = "The quick brown fox   jumps over      the lazy dog..."
local result = {}
for word in string.gmatch(text, "[^ ]+") do -- M√≠sto "[^ ]+" by ≈°lo pou≈æ√≠t nap≈ô. "%a+" (https://www.lua.org/pil/20.2.html)
    table.insert(result, word)
end
print(table.concat(result, ", ")) --> The, quick, brown, fox, jumps, over, the, lazy, dog...
```

Split podle konr√©tn√≠ho pod≈ôetƒõzce / v√Ωrazu je komplikovanƒõj≈°√≠, m≈Ø≈æeme zkusit funkci:

```lua
local function string_split(text, pattern)
    local result = {}
    local last_index_after
    -- "(.-)pattern" matches least amount of characters followed by the pattern; "()" matches index after said pattern
    for match, index_after in string.gmatch(text, "(.-)" .. pattern .. "()") do
        table.insert(result, match)
        last_index_after = index_after
    end
    -- If there was no match (result table is empty) then return one item table with input text (no splitting was made)
    if next(result) == nil then
        return { text }
    end
    -- If the text does not end with pattern, then there's still last group of characters missing from the table,
    -- that's why we keep track of the index after last match
    if last_index_after ~= nil and last_index_after <= #text then
        table.insert(result, string.sub(text, last_index_after))
    end
    return result
end
```

### Vyzob√°n√≠ hodnot z ≈ôetƒõzce √† la `sscanf`

Pop√≠≈°eme-li dan√Ω ≈ôetƒõzec vzorem a oz√°vorkujeme ƒç√°sti, je≈æ n√°s zaj√≠maj√≠, m≈Ø≈æeme je pomoc√≠ `string.match` rovnou ulo≈æit do promƒõnn√Ωch:

```lua
local text = "brown     fox"
local left, right = text:match("(%a+)%s+(%a+)") -- Zkr√°cen√≠ string.match(text, "(%a+)%s+(%a+)")
print(left .. "-" .. right) --> brown-fox
```

(Oproti `gmatch`, kter√Ω iteruje p≈ôes v≈°echny n√°lezy, se `match` zastav√≠ u prvn√≠ho n√°lezu.)

## P≈ôevody

```lua
-- string ‚Üí int
local number = tonumber("20") --> 20

-- string ‚Üí char array
local text = "Abrakadabra Alakazam"
local collection = {}
for i=1,#text do table.insert(collection, text:sub(i,i)) end -- text:sub(i,i) == string.sub(text,i,i)
print(table.concat(collection, ", ")) --> A, b, r, a, k, a, d, a, b, r, a,  , A, l, a, k, a, z, a, m
```

## Skoky

Skoky typu `goto` neb√Ωvaj√≠ pova≈æov√°ny za _good practice_, lze je ale nap≈ô. pou≈æ√≠t pro ‚Äûbreaknut√≠‚Äú vnƒõj≈°√≠ho cyklu:

```lua
for i=1,10 do
    for j=1,10 do
        if i == 5 and j == 7 then
            goto outer_loop_end
        end
    end
end
::outer_loop_end::
```

Pomoc√≠ skok≈Ø lze tak√© implementovat `continue`, kter√© Lua nem√°.
