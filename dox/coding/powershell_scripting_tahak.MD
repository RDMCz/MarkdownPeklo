# PowerShell scripting tahÃ¡k

> [!NOTE]  
> Toto zdaleka nenÃ­ veÅ¡kerÃ½ vÃ½Äet funkcÃ­ a vlastnostÃ­ danÃ©ho programovacÃ­ho jazyka.<br>JednÃ¡ se pouze o&nbsp;mÃ© zÃ¡pisky vzniklÃ© bÄ›hem Å™eÅ¡enÃ­ [AoC](https://github.com/RDMCz/AdventOfCode) a/nebo pÅ™i (samo)studiu.<br><br>ZÃ¡roveÅˆ se zde vÅ¯bec nezabÃ½vÃ¡m administracÃ­ OS Windows z prostÅ™edÃ­ PowerShell,<br>ale pouze prostÅ™edky pro psanÃ­ â€bÄ›Å¾nÃ½châ€œ algoritmÅ¯.

* [PÅ™ivÃ­tÃ¡nÃ­](#pÅ™ivÃ­tÃ¡nÃ­)
* [PromÄ›nnÃ© a jejich vÃ½pis](#promÄ›nnÃ©-a-jejich-vÃ½pis)
* [Å˜etÄ›zce a backtick](#Å™etÄ›zce-a-backtick)
* [Operace s Å™etÄ›zci](#operace-s-Å™etÄ›zci)
* [DatovÃ© typy a pÅ™evody](#datovÃ©-typy-a-pÅ™evody)
* [PodmÃ­nky a nearitmetickÃ© operÃ¡tory](#podmÃ­nky-a-nearitmetickÃ©-operÃ¡tory)
* [Cykly](#cykly)
* Kolekce
  * [Pole](#pole)
  * [VÃ­cerozmÄ›rnÃ¡ pole](#vÃ­cerozmÄ›rnÃ¡-pole)
  * [List](#list)
  * [AsociativnÃ­ pole](#asociativnÃ­-pole)
* [OOP](#oop)

## PÅ™ivÃ­tÃ¡nÃ­

```ps1
Write-Host -Object "Hello world!"

Write-Host "Hello world!"
Write-Host "Hello world!" -ForegroundColor Black -BackgroundColor White
```

PÅ™Ã­kaz (â€cmdletâ€œ) `Write-Host` vypisuje hodnotu parametru `-Object` do terminÃ¡lu. Parametr `-Object` nenÃ­ tÅ™eba uvÃ¡dÄ›t, tedy `Write-Host -Object "abc"` se chovÃ¡ stejnÄ› jako `Write-Host "abc"`. PÅ™Ã­kaz mÃ¡ k dispozici dalÅ¡Ã­ parametry, jejichÅ¾ hodnoty mÅ¯Å¾eme definovat, napÅ™. barva popÅ™edÃ­ a pozadÃ­. ObecnÄ› tedy pÃ­Å¡eme `PÅ™Ã­kaz -Parametr Hodnota`.

KompletnÃ­ info o pÅ™Ã­kazu lze nalÃ©zt v MS dokumentaci, v tomto pÅ™Ã­padÄ› [Write-Host](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/write-host). NÃ¡zvy pÅ™Ã­kazÅ¯ splÅˆujÃ­ konvenci pojmenovÃ¡nÃ­ `Verb-Noun`: verb Å™Ã­kÃ¡, jakÃ¡ akce bude provedena (_Write_), a noun Å™Ã­kÃ¡, s ÄÃ­m bude tato akce provedena (_Host_).

PÅ™Ã­kaz `Write-Host` ve skuteÄnosti nepotÅ™ebuje ani uvozovky; dokud nenarazÃ­ na parametr, tak se snaÅ¾Ã­ vÅ¡e pÅ™evÃ©st na text. Proto funguje takÃ© `Write-Host Hello world!`, urÄitÄ› se ale nejednÃ¡ o best practice.

## PromÄ›nnÃ© a jejich vÃ½pis

```ps1
<#
NÃ¡zev promÄ›nnÃ© zaÄÃ­nÃ¡ dolarem.
#>
$number5 = 5
$number6 = 6
$text = "ooga booga"

<#
Å˜Ã¡dek obsahujÃ­cÃ­ samotnÃ½ nÃ¡zev promÄ›nnÃ© vypÃ­Å¡e (pÅ™Ã­padnÄ› i vracÃ­) jejÃ­ hodnotu,
stejnÄ› jako kdybychom napsali nÃ¡zev promÄ›nnÃ© do terminÃ¡lu â€“ odpovÄ›dÃ­ je hodnota.
#>
Write-Host $number5  # â†’ 5
$number5             # â†’ 5

<#
PÅ™Ã­kaz Write-Host implicitnÄ› nevyhodnocuje vÃ½razy, je potÅ™eba pouÅ¾Ã­t zÃ¡vorky.
#>
$number5 + $number6               # â†’ 11
Write-Host $number5 + $number6    # â†’ 5 + 6
Write-Host ($number5 + $number6)  # â†’ 11

Write-Host ($text + " " + $text)          # â†’ ooga booga ooga booga
Write-Host ($text + $number5 + $number6)  # â†’ ooga booga56
Write-Host ($number5 + $text)             # Error

<#
Pro "string interpolation" samostatnÃ© promÄ›nnÃ© ideÃ¡lnÄ› pouÅ¾Ã­t ${}.
Pro vÃ½razy je tÅ™eba $().
#>
Write-Host "Hodnota jest $number5..."                # â†’ Hodnota jest 5...
Write-Host "Hodnota jest ${number5}..."              # â†’ Hodnota jest 5...
Write-Host "Hodnota jest ($number5 + $number6)..."   # â†’ Hodnota jest (5 + 6)...
Write-Host "Hodnota jest $($number5 + $number6)..."  # â†’ Hodnota jest 11...
Write-Host "Hodnota jest $($number5)..."             # â†’ Hodnota jest 5...

<#
PomocÃ­ New-Variable, Get-Variable, Set-Variable lze s promÄ›nnÃ½mi pracovat â€dynamickyâ€œ...
#>
$var1name = "x1"
$var1val = 100
$var2name = "x2"
$var2val = 200

New-Variable -Name $var1name -Value $var1val
$x2 = $var2val

Write-Host $x1                                  # â†’ 100
Write-Host (Get-Variable $var2name -ValueOnly)  # â†’ 200
```

## Å˜etÄ›zce a backtick

PowerShell pouÅ¾Ã­vÃ¡ backtick (`` ` ``) jako escape character.

```ps1
Write-Host "Row 1`nRow 2`nRow 3"
Write-Host "1`" = 2.54 cm"
<# â†’
Row 1
Row 2
Row 3
1" = 2.54 cm
#>
```

Å˜etÄ›zec v jednoduchÃ½ch uvozovkÃ¡ch (`'`) se nazÃ½vÃ¡ _verbatim string_ a nefunguje v nÄ›m Å¾Ã¡dnÃ¡ interpolace ani escapovÃ¡nÃ­.

```ps1
Write-Host 'Row 1`nRow 2`nRow 3'
Write-Host '1" = 2.54 cm'
Write-Host 'Jednoducha uvozovka ('') ve verbatim stringu escapuje sama sebe.'
<# â†’
Row 1`nRow 2`nRow 3
1" = 2.54 cm
Jednoducha uvozovka (') ve verbatim stringu escapuje sama sebe.
#>
```

VÃ­ceÅ™Ã¡dkovÃ© Å™etÄ›zce lze psÃ¡t pomocÃ­ tzv. _here-strings_, kterÃ© berou v potaz novÃ© Å™Ã¡dky ve zdrojovÃ©m kÃ³du. MusÃ­ zaÄÃ­nat otevÃ­racÃ­ znaÄkou `@'` nebo `@"` nÃ¡sledovanou novÃ½m Å™Ã¡dkem a konÄit uzavÃ­racÃ­ znaÄkou `'@` nebo `"@`, kterÃ© pÅ™edchÃ¡zÃ­ novÃ½ Å™Ã¡dek.

```ps1
Write-Host @'
Row 1
Row 2
Row 3
'@
Write-Host @"
Row 4
Row ${number5}
Row ${number6}
"@
<# â†’
Row 1
Row 2
Row 3
Row 4
Row 5
Row 6
#>
```

## Operace s Å™etÄ›zci

### Substring

```ps1
$str = "abcdefghi"

# Od indexu 2 do konce
Write-Host ($str.Substring(2))  # â†’ cdefghi

# 3 znaky poÄÃ­naje indexem 2
Write-Host ($str.Substring(2, 3))  # â†’ cde

# ($str[2..4]) vracÃ­ kolekci znakÅ¯ od indexu 2 do indexu 4 (vÄetnÄ›)
# ($str[2..4] -join "") spojÃ­ prvky kolekce do Å™etÄ›zce (mezi jednotlivÃ© prvky je vloÅ¾eno "", tedy nic)
# Pokud â€joinujeme niÄÃ­mâ€œ, mÅ¯Å¾eme pouÅ¾Ã­t kratÅ¡Ã­ unÃ¡rnÃ­ variantu (-join $str[2..4])
Write-Host (-join $str[2..4])  # â†’ cde

# Pro indexovou verzi ($str.Substring(2)) potÅ™ebujeme zjistit dÃ©lku,
# nebo pouÅ¾Ã­t libovolnÃ© dostateÄnÄ› velkÃ© ÄÃ­slo â€“ out of bounds nevadÃ­
Write-Host (-join $str[2..($str.Length - 1)])  # â†’ cdefghi
Write-Host (-join $str[2..99])                 # â†’ cdefghi

# Indexace odzadu
Write-Host (-join $str[-7..-5])  # â†’ cde

# Indexace pozpÃ¡tku
Write-Host (-join $str[4..2])  # â†’ edc
```

### -replace

```ps1
$str = "powershell (mocna lastura)"                       #   powershell (mocna lastura)
Write-Host ($str -replace "lastura", "skorapka")          # â†’ powershell (mocna skorapka)
Write-Host ($str -replace ".{8}$", "skorapka)")           # â†’ powershell (mocna skorapka)
Write-Host ($str -replace "[^a-z ]")                      # â†’ powershell mocna lastura

# V regulÃ¡rnÃ­ch vÃ½razech escapujeme backslashem, nikoliv backtickem.
# Pro nahrazenÃ­ nalezenou skupinou regulÃ¡rnÃ­ho vÃ½razu je tÅ™eba jako druhÃ½ parametr pouÅ¾Ã­t verbatim string,
# ve kterÃ©m pÅ™Ã­padnÄ› dolar escapuje sÃ¡m sebe.
Write-Host ($str -replace ".*\((\w+) (\w+)\)", '$2 $1')      # â†’ lastura mocna
Write-Host ($str -replace ".*\((\w+) (\w+)\)", '$2 $$1')     # â†’ lastura $1

# AlternativnÄ› escapnout backtickem dolar v bÄ›Å¾nÃ©m stringu. 
Write-Host ($str -replace ".*\((\w+) (\w+)\)", "`$2 `$1")    # â†’ lastura mocna
Write-Host ($str -replace ".*\((\w+) (\w+)\)", "`$2 `$`$1")  # â†’ lastura $1
```

VÃ­ce o regulÃ¡rnÃ­ch vÃ½razech (â€regexâ€œ) v PowerShellu na [MSLearn/about_Regular_Expressions](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_regular_expressions?view=powershell-5.1).

### -split

```ps1
function Demonstruj($splitted) {
    Write-Host ($splitted -join " | ")
}

$text = "a,b c,d  e,,f"

# SamotnÃ½ split dÄ›lÃ­ podle mezer a vÃ­ce mezer za sebou je stÃ¡le jeden split
Demonstruj (-split $text)  # â†’ a,b | c,d | e,,f

# V binÃ¡rnÃ­ variantÄ› dÄ›lÃ­me podle podÅ™etÄ›zce, vÃ­ce vÃ½skytÅ¯ za sebou je ale splitovÃ¡no zvlÃ¡Å¡Å¥
Demonstruj ($text -split ",")  # â†’ a | b c | d  e |  | f

# Pro zachovÃ¡nÃ­ delimiteru ho obalÃ­me do zÃ¡vorek; escapujeme pÅ™Ã­padnÄ› backslashem
Demonstruj ($text -split "(,)")  # â†’ a | , | b c | , | d  e | , |  | , | f

# Lze si napsat vlastnÃ­ podmÃ­nku
Demonstruj ($text -split { $_ -eq " " -or $_ -eq "," })  # â†’ a | b | c | d |  | e |  | f
Demonstruj ($text -split { $_ -in @(" ", ",") })         # â†’ a | b | c | d |  | e |  | f

# Pro case sensitive splitovÃ¡nÃ­ potÅ™ebujeme -csplit
Demonstruj ("aAaAaAa" -split "A")   # â†’  |  |  |  |  |  |  |
Demonstruj ("aAaAaAa" -csplit "A")  # â†’ a | a | a | a
```

## DatovÃ© typy a pÅ™evody

```ps1
# PromÄ›nnÃ© nemusÃ­ mÃ­t pevnÄ› nastavenÃ½ datovÃ½ typ
$real = 1.2
Write-Host $real.GetType()  # â†’ System.Double
$real = "1.2"
Write-Host $real.GetType()  # â†’ System.String

# Pro pÅ™evod lze pouÅ¾Ã­t tzv. casting, pozor pÅ™i uklÃ¡dÃ¡nÃ­ do promÄ›nnÃ©
$real = [float]1.2
Write-Host $real.GetType()  # â†’ System.Single
$real++
Write-Host $real.GetType()  # â†’ System.Double

# Pro pevnÄ› nastavenÃ½ datovÃ½ typ promÄ›nnÃ© castovat identifikÃ¡tor, nikoliv hodnotu
[float]$real = 1.2
Write-Host $real.GetType()  # â†’ System.Single
$real++
Write-Host $real.GetType()  # â†’ System.Single

# Pro ovÄ›Å™enÃ­ datovÃ©ho typu lze pouÅ¾Ã­t operÃ¡tor -is
Write-Host $(64 -is [int])  # â†’ True

# PÅ™ed castovÃ¡nÃ­m vhodno pouÅ¾Ã­t -as a vÃ½sledek porovnat s $null pomocÃ­ -eq
Write-Host $("64" -as [int])                # â†’ 64
Write-Host $("abcd" -as [int])              # (Nic)
Write-Host $([int]"abcd")                   # Error
Write-Host $($null -eq ("abcd" -as [int]))  # â†’ True

# Pozor na aritmetiku Å™etÄ›zcÅ¯
Write-Host ("50" + "3")  # â†’ 503
Write-Host ("50" - "3")  # â†’ 47
Write-Host ("50" / "3")  # â†’ 16.6666666666667
Write-Host ("50" * "3")  # â†’ 505050
```

## PodmÃ­nky a nearitmetickÃ© operÃ¡tory

```ps1
if ($num -eq 1) { <#...#> }
elseif ($num -eq 2) { <#...#> }
else { <#...#> }
```

PodmÃ­nky fungujÃ­ podobnÄ› jako ve vÄ›tÅ¡inÄ› â€bÄ›Å¾nÃ½châ€œ jazycÃ­ch, rozdÃ­l je ale v operÃ¡torech. Krom toho, Å¾e se nepouÅ¾Ã­vajÃ­ symboly, mÃ¡ vÄ›tÅ¡ina operÃ¡torÅ¯ dvÄ› varianty liÅ¡Ã­cÃ­ se v tom, zdali Å™eÅ¡Ã­ Äi neÅ™eÅ¡Ã­ velikosti pÃ­smen pÅ™i porovnÃ¡vÃ¡nÃ­ Å™etÄ›zcÅ¯.

```ps1
if ("lalilulelo" -eq "LaLiLuLeLo") {   # -eq neboli case-insensitive equality
    # Tohle se provede
}
if ("lalilulelo" -ceq "LaLiLuLeLo") {  # -ceq neboli case-sensitive equality
    # Tohle uÅ¾ ne
}
```

Pokud porovnÃ¡vÃ¡me rÅ¯znÃ© datovÃ© typy, nedostaneme chybu, ale vÃ½sledek nemusÃ­ bÃ½t na prvnÃ­ pohled zÅ™ejmÃ½. PowerShell se totiÅ¾ snaÅ¾Ã­ pÅ™evÃ©st druhÃ½ operand na typ toho prvnÃ­ho.

```ps1
Write-Host ("5" -eq 5)     # â†’ True, "5" == "5"
Write-Host ("50" -gt 30)   # â†’ True, Å™etÄ›zec "50" je nÄ›kde za Å™etÄ›zcem "30" (pokud je seÅ™adÃ­me â€abecednÄ›â€œ)
Write-Host ("50" -gt 300)  # â†’ True, "50" je i za Å™etÄ›zcem "300"
Write-Host ("50" -gt 70)   # â†’ False, "50" pÅ™edchÃ¡zÃ­ Å™etÄ›zci "70"
Write-Host ("50" -gt 7)    # â†’ False, "50" pÅ™edchÃ¡zÃ­ i Å™etÄ›zci "7"
```

ZÃ¡kladnÃ­ relaÄnÃ­ operÃ¡tory jsou `-eq`, `-ne`, `-gt`, `-ge`, `-lt`, `-le` a jejich case-sensitive verze, kterÃ© zaÄÃ­najÃ­ pÃ­smenem `c`. DatovÃ© typy lze porovnÃ¡vat pomocÃ­ `-is` a `-isnot`. LogickÃ© operÃ¡tory jsou pak `-and`, `-or`, `-not` (lze pouÅ¾Ã­t alias `!`) a `-xor`. K dispozici jsou takÃ© bitovÃ© operace, napÅ™. `band` nebo `shl`.

### -like a -match

```ps1
# `*` je libovolnÃ½ poÄet znakÅ¯, `?` je jeden znak
"Windows 10 x64" -like "Windows * x??"
# -like, -notlike, -clike, -cnotlike

# Regex
"Windows 10 x64" -match "Windows .* x\d\d"
# -match, -notmatch, -cmatch, -cnotmatch
```

### PÅ™iÅ™azenÃ­ ifu

```ps1
$num = if ($podminka) {
    return 1
} else {
    return 0
}
```

### Switch

Switch pro vstupnÃ­ hodnotu postupnÄ› zkouÅ¡Ã­ vÅ¡echny svÃ© podmÃ­nky a u tÄ›ch vyhovujÃ­cÃ­ch provede pÅ™Ã­kazy v jejich tÄ›le. Pro ukonÄenÃ­ vyhodnocovÃ¡nÃ­ lze pouÅ¾Ã­t `continue` nebo `break` (nÄ›kterÃ© vlastnosti switche zaÄnou dÃ¡vat smysl aÅ¾ pÅ™i pouÅ¾itÃ­ s kolekcemi). Pro porovnÃ¡vÃ¡nÃ­ Å™etÄ›zcÅ¯ jsou k dispozici parametry `-CaseSensitive` (v defaultu nenÃ­), `-Wildcard` (analogickÃ© k `-like`) a `-Regex` (analogickÃ© k `-match`).

```ps1
$num = 5

switch ($num) {
    4 {  # Nic
        Write-Host "4"
    }
    5 {  # Match
        Write-Host "5"
    }
    6 {  # Nic
        Write-Host "6"
    }
    { $_ % 2 -ne 0 } {  # Match, pro vyhodnocenÃ­ lze pouÅ¾Ã­t scriptblock; $_ obsahuje aktuÃ¡lnÄ› zkoumanou hodnotu
        Write-Host '$_ % 2 -ne 0'
    }
    "5" {  # Match, { 5 -eq "5" } je v vyhodnoceno jako $true; museli bychom pouÅ¾Ã­t { $_ -is [string] -and $_ -eq "5" }
        Write-Host '"5"'
    }    
    5 {  # Match, stejnÃ¡ podmÃ­nka nevadÃ­
        Write-Host "5"
    }
    Default {  # Nic, platnÃ© pouze pokud nebyla pouÅ¾ita Å¾dÃ¡nÃ¡ jinÃ¡ vÄ›tev
        Write-Host "Default"
    }
}

<# â†’
5
$_ % 2 -ne 0
"5"
5
#>
```

## Cykly

* For &ensp;`for ($i = 1; $i -lt 5; $i++) { ... }`
* While &ensp;`while ($i -lt 5) { ... }`
* Do-while &ensp;`do { ... } while ($i -lt 5)`
* Do-until &ensp;`do { ... } until ($i -ge 5)`
* Foreach, switch
* `break`, `continue`

```ps1
:label while ($podminka1) {
    while ($podminka2) {
        ...
        break label  # VyskoÄÃ­ z cyklu oznaÄenÃ©ho jako "label"
    }
}
```

## Kolekce

### Pole

#### [Pole] VytvoÅ™enÃ­, vÃ½pis

```ps1
# Pole jsou ve vÃ½chozÃ­m stavu heterogennÃ­, resp. pole objektÅ¯
$pole = @(1, 2, "Three", 4.01)
Write-Host $pole               # â†’ 1 2 Three 4.01
Write-Host ($pole -join ", ")  # â†’ 1, 2, Three, 4.01
Write-Host $pole.Count         # â†’ 4
Write-Host $pole.GetType()     # â†’ System.Object[]

# POZOR na nÃ¡sobenÃ­ uvnitÅ™ vÃ½Ätu poloÅ¾ek
Write-Host @(1, 2, 3 * 5)    # â†’ 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3
Write-Host @(1, 2, (3 * 5))  # â†’ 1 2 15

# MÃ­sto ÄÃ¡rek lze pouÅ¾Ã­t novÃ© Å™Ã¡dky
$pole = @(
    1
    2
    "Three"
    4.01
)

# DalÅ¡Ã­ kuriozita je podmÃ­nka uvnitÅ™ vÃ½Ätu
$podminka = $false
$pole = @(1, 2, $(if ($podminka) { 3, 4 } else { 5, 6 }))
Write-Host $pole  # â†’ 1 2 5 6

# KromÄ› vÃ½Ätu poloÅ¾ek lze vytvoÅ™it i prÃ¡zdnÃ© pole s pevnÄ› danou dÃ©lkou
$pole = [Object[]]::new(4)  # ÄŒtyÅ™teÄkou pÅ™istupujeme ke statickÃ½m ÄlenÅ¯m

# PevnÄ› nastavenÃ½ datovÃ½ typ uÅ¾ umÃ­me
[int[]]$pole = @(0, 1, 2, 3, 4, 5, 6, 7)

# VÃ½Äet rozsahem
[int[]]$pole = @(0..7)
```

#### [Pole] Indexace

```ps1
[int[]]$pole = @(0, 1, 2, 3, 4, 5, 6, 7)
Write-Host $pole[1]  # â†’ 1

# Lze indexovat vÃ­ce poloÅ¾ek najednou, nebo rozsah (exkluzivnÃ­)
Write-Host $pole[1, 2, 3]  # â†’ 1 2 3
Write-Host $pole[1, 0, 1]  # â†’ 1 0 1
Write-Host $pole[1..4]     # â†’ 1 2 3 4
Write-Host $pole[4..1]     # â†’ 4 3 2 1

# Lze indexovat od konce
Write-Host $pole[-1]  # â†’ 7
Write-Host $pole[-2]  # â†’ 6

<#
POZOR!
IndexovÃ¡nÃ­ rozsahem nenÃ­ to samÃ©, jako plnohodnotnÃ½ slicing.
Od [1..-2] bychom mohli Äekat oÅ™Ã­znutÃ­ o jeden prvek z obou stran,
ve skuteÄnosti je ale vygenerovÃ¡na sekvence [1,0,-1,-2].
#>
Write-Host $pole[1..-2]  # â†’ 1 0 7 6

# Co s tÃ­m?
Write-Host $pole[1..($pole.Count - 2)]                                  # â†’ 1 2 3 4 5 6
Write-Host $pole[1..($pole.GetUpperBound(0) - 1)]                       # â†’ 1 2 3 4 5 6
Write-Host ($pole | Select-Object -Skip 1 | Select-Object -SkipLast 1)  # â†’ 1 2 3 4 5 6

# Out of bounds v PowerShellu vracÃ­ $null, Å¾Ã¡dnÃ© errory
Write-Host ($null -eq $pole[10])  # â†’ True

# To samÃ© ale neplatÃ­ o nastavovÃ¡nÃ­ hodnot
$pole[2] = 20    # OK
$pole[10] = 100  # IndexOutOfRangeException

# Indexovat lze pÅ™Ã­padnÄ› i jinÃ½m polem
$indexes = @(4, 5, 6)
Write-Host $pole[$indexes]  # â†’ 4 5 6
```

#### [Pole] Iterace

Iterovat pole stylem _foreach_ lze tÅ™emi zpÅ¯soby. `$_` je vestavÄ›nÃ¡ promÄ›nnÃ¡ obsahujÃ­cÃ­ aktuÃ¡lnÃ­ prvek.

```ps1
foreach ($item in $pole) {
    Write-Host (2 * $item)
}

$pole | ForEach-Object {
    Write-Host (2 * $_)
}

$pole.ForEach({
    Write-Host (2 * $_)
})
```

Co kdyÅ¾ chceme i index aktuÃ¡lnÃ­ho prvku?

```ps1
# ForEach-Object mÅ¯Å¾e mÃ­t aÅ¾ tÅ™i ÄÃ¡sti: `ForEach-Object -Begin {} -Process {} -End {}`
# Zde nÃ¡m vyhovuje implicitnÃ­ urÄenÃ­ blokÅ¯, kde v Begin nastavÃ­me index a v Process inkrementujeme
$pole | ForEach-Object { $index = 0 } {
    Write-Host "${index}: ${_}"
    $index++
}

# VygenerovÃ¡nÃ­ sekvence pomocÃ­ rozsahu a indexovÃ¡nÃ­ pole
0..($pole.Count - 1) | ForEach-Object {
    Write-Host "${_}: $($pole[$_])"
}

# Nebo lze pouÅ¾Ã­t klasickÃ½ for cyklus
for ($index = 0; $index -lt $pole.Count; $index++) {
    Write-Host "${index}: $($pole[$index])"
}
```

PÅ™iÅ™azenÃ­m cyklu foreach do promÄ›nnÃ© mÅ¯Å¾eme vytvoÅ™it novÃ© pole.

```ps1
# VytvoÅ™enÃ­ pole pomocÃ­ foreach
$pole = 0..9 | ForEach-Object {
    return 2 * $_
}
Write-Host $pole  # â†’ 0 2 4 6 8 10 12 14 16 18
```

Switch umoÅ¾Åˆuje reagovat na jednotlivÃ© hodnoty v poli.

```ps1
switch ($pole) {
    { $_ % 2 -eq 0 } {
        Write-Host "Sude"        
    }
    Default {
        Write-Host "Liche"
    }
}
```

Ve vÄ›tvÃ­ch switche mÅ¯Å¾eme pouÅ¾Ã­vat `continue` a `break`, kterÃ© fungujÃ­ analogicky k ostatnÃ­m cyklÅ¯m. TakÃ© lze vyuÅ¾Ã­vat metody automaticky spravovanÃ© promÄ›nnÃ© `$switch`, napÅ™. pro vrÃ¡cenÃ­ nÃ¡sledujÃ­cÃ­ hodnoty v kolekci.

#### [Pole] SÄÃ­tÃ¡nÃ­, nÃ¡sobenÃ­

Pole lze spojovat operacÃ­ souÄtu. K poli lze pÅ™iÄÃ­st jednu poloÅ¾ku nebo druhÃ© pole. PÅ™iÄtenÃ­m se zvÄ›tÅ¡Ã­ jeho dÃ©lka â€“ do promÄ›nnÃ© je pÅ™iÅ™azeno novÃ© pole, kterÃ© je vÃ½sledkem souÄtu. Pole lze takÃ© nÃ¡sobit kladnÃ½m ÄÃ­slem, dÃ­ky tomu lze snadno vytvoÅ™it pole s vÃ½chozÃ­ hodnotou.

```ps1
[int[]]$pole1 = @(0, 1)
[int[]]$pole2 = @(2, 3)

# SÄÃ­tÃ¡nÃ­ polÃ­
[int[]]$pole3 = $pole1 + $pole2
Write-Host "${pole3} `t[$($pole3.Count)]"  # â†’ 0 1 2 3         [4]
$pole3 += 4
Write-Host "${pole3} `t[$($pole3.Count)]"  # â†’ 0 1 2 3 4       [5]
$pole3 += @(5, 6)
Write-Host "${pole3} `t[$($pole3.Count)]"  # â†’ 0 1 2 3 4 5 6   [7]

# VynÃ¡sobenÃ­ pole ÄÃ­slem
$pole3 *= 2
Write-Host "${pole3} `t[$($pole3.Count)]"  # â†’ 0 1 2 3 4 5 6 0 1 2 3 4 5 6     [14]
Write-Host (@(1) * 14)                     # â†’ 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```

#### [Pole] SeÅ™azenÃ­

```ps1
[int[]]$pole_unsorted = @(0, 3, 5, 2, 6, 7, 4, 1)
[int[]]$pole_sorted = ($pole_unsorted | Sort-Object)
Write-Host $pole_sorted  # â†’ 0 1 2 3 4 5 6 7
```

#### [Pole] OdstranÄ›nÃ­ prvku

Z polÃ­ nelze pÅ™Ã­mo odstraÅˆovat prvky â€“ majÃ­ pevnou dÃ©lku â€“ a neexistuje ani operace odÄÃ­tÃ¡nÃ­ polÃ­. MÅ¯Å¾eme vÅ¡ak hodnoty pole filtrovat a pÅ™idÃ¡vat do pole novÃ©ho, nebo sÄÃ­tat vybranÃ© ÄÃ¡sti pole.

```ps1
# MazÃ¡nÃ­ podle hodnoty
[int[]]$pole_unfiltered = @(0, 1, 2, 3, 0, 1, 2, 3)
$pole_filtered1 = ($pole_unfiltered | Where-Object { $_ -ne 0 })
Write-Host $pole_filtered1  # â†’ 1 2 3 1 2 3
# â€SmaÅ¾eâ€œ vÅ¡echny nuly; pÅ™idÃ¡nÃ­m pomocnÃ© promÄ›nnÃ© a podmÃ­nky lze mazat jen prvnÃ­ vÃ½skyt
# Takto jednoduchÃ½ filtr lze zapsat kompaktnÄ›ji (probrÃ¡no v nÃ¡sledujÃ­cÃ­ sekci), toto je ale obecnÄ›jÅ¡Ã­

# MazÃ¡nÃ­ podle indexu DIY
$index_to_remove = 2
$pole_filtered2 =
    [int[]]($pole_unfiltered | Select-Object -SkipLast ($pole_unfiltered.Count - $index_to_remove)) +
    ($pole_unfiltered | Select-Object -Skip ($index_to_remove + 1))
Write-Host $pole_filtered2  # â†’ 0 1 3 0 1 2 3
```

### Pole a relaÄnÃ­ operÃ¡tory

```ps1
<#
PouÅ¾itÃ­ operÃ¡torÅ¯ -eq, -ne, -gt, ... na kolekci vracÃ­ vÅ¡echny jejÃ­ prvky, kterÃ© jsou vyhodnoceny jako true.
#>
[int[]]$pole_unfiltered = @(0, 1, 2, 3, 0, 1, 2, 3)
$pole_filtered = $pole_unfiltered -ne 0
Write-Host $pole_filtered  # â†’ 1 2 3 1 2 3

<#
-contains, -notcontains, -ccontains, -cnotcontains, -in, -notin, -cin, -cnotin
#>
Write-Host (@("a", "b", "c") -contains "B")  # â†’ True
Write-Host ("B" -cnotin @("a", "b", "c"))    # â†’ True
```

### VÃ­cerozmÄ›rnÃ¡ pole

Pole lze samozÅ™ejmÄ› vnoÅ™ovat â€“ â€zubatÃ¡â€œ pole tak lze vytvoÅ™it snadno.

```ps1
# ZavinÃ¡Äe u vnoÅ™enÃ½ch polÃ­ nejsou povinnÃ©
$hyperpole = @(0, 1, (21, 22, 23, 24), 3, (41, 42, 43, 44))

Write-Host $hyperpole[1]        # â†’ 1
Write-Host $hyperpole[2]        # â†’ 21 22 23 24
Write-Host $hyperpole[2][1]     # â†’ 22
Write-Host $hyperpole[2][1][1]  # (â†’ $null)

# Pole je klasicky typu System.Object[], jak to ale vypadÃ¡ s typy uvnitÅ™?
Write-Host "$($hyperpole[0].GetType()), $($hyperpole[2].GetType()), $($hyperpole[2][1].GetType())"
<#
â†’ int, System.Object[], int
Pokud bychom chtÄ›li vnoÅ™enÃ¡ pole explicitnÄ› otypovat, je lepÅ¡Ã­ pÅ™ed kaÅ¾dÃ© napsat [int[]],
neÅ¾ se pokouÅ¡et o [int[][]] apod. pÅ™ed celÃ½m polem.
#>

# VnoÅ™enÃ¡ pole lze takÃ© generovat pomocÃ­ foreach
1..5 | ForEach-Object { return , @($_, ($_ * 2)) }
# Vygeneruje [ [ 1 2 ] [ 2 4 ] [ 3 6 ] [ 4 8 ] [ 5 10 ] ]

# ÄŒÃ¡rka mezi `return` a polem je nutnÃ¡, jinak bude PowerShell pole â€rozbalovatâ€œ
1..5 | ForEach-Object { return @($_, ($_ * 2)) }
# Vygeneruje [ 1 2 2 4 3 6 4 8 5 10 ]
```

Pro â€tradiÄnÄ›jÅ¡Ã­â€œ vÃ­cerozmÄ›rnÃ¡ pole s pevnÃ½mi rozmÄ›ry lze pouÅ¾Ã­t pÅ™Ã­kaz `New-Object`, kterÃ½ vracÃ­ instanci vyÅ¾Ã¡danÃ©ho .NET objektu.

```ps1
$matrix = New-Object "int[,]" 6, 4

$height = $matrix.GetLength(0)  # 6
$width = $matrix.GetLength(1)   # 4

0..($height - 1) | ForEach-Object {
    $y = $_                                     # 0000
    0..($width - 1) | ForEach-Object {          # 0000
        $x = $_                                 # 0000
        Write-Host -NoNewline $matrix[$y, $x]   # 0000
    }                                           # 0000
    Write-Host                                  # 0000
}
```

### List

Z kolekcÃ­ frameworku .NET si mÅ¯Å¾eme vypÅ¯jÄit List â€“ homogennÃ­ a gumovÃ½.

```ps1
$list = [System.Collections.Generic.List[string]]::new()
$list = [System.Collections.Generic.List[int]]@(0, 1, 2, 3)
$list.Add(4)
[void]$list.Remove(2)  # Bez [void] vypisuje True do konzole
Write-Host $list       # â†’ 0 1 3 4
```

### AsociativnÃ­ pole

#### Hashtable

Ãšlohu asociativnÃ­ho pole v PowerShellu nativnÄ› zastupuje heterogennÃ­ key-value ÃºloÅ¾iÅ¡tÄ› zvanÃ© _hashtable_.

```ps1
<# Metody pro vytvoÅ™enÃ­ hashtable a nastavenÃ­ jeho hodnot #>
$hshtbl = @{}                 # PrÃ¡zdnÃ¡ hashtable
$hshtbl[0] += 5               # PÅ™iÄÃ­tÃ¡nÃ­ k neexistujÃ­cÃ­mu klÃ­Äi nevadÃ­
$hshtbl["abc"] = "def"        # String klÃ­Ä; to, Å¾e uÅ¾ jsme pouÅ¾ili int klÃ­Ä, nevadÃ­
$conv = @{"1" = 1; "2" = 2 }  # Hashtable s vÃ½Ätem pÃ¡rÅ¯; je-li kaÅ¾dÃ½ pÃ¡r zapsÃ¡n na novÃ©m Å™Ã¡dku, pak lze stÅ™ednÃ­ky vynechat
$conv.Add("3", 3)             # Lze pouÅ¾Ã­t i metodu Add
$conv."4" = 4                 # Nebo metodu pÅ™Ã­stupu ke ÄlenÅ¯m

<# Metody pro pÅ™Ã­stup k prvkÅ¯m hashtable #>
Write-Host $hshtbl[0]         # â†’ 5
Write-Host $hshtbl["abc"]     # â†’ def
Write-Host $hshtbl[99]        # (â†’ $null)
Write-Host $hshtbl.0          # â†’ 5
Write-Host $hshtbl."abc"      # â†’ def

# Pro zjiÅ¡tÄ›nÃ­ vÅ¡ech dostupnÃ½ch metod a vlasnostÃ­ pouÅ¾ijeme `$hshtbl | Get-Member`
```

Hashtable je pÅ™Ã­klad objektu, kdy se vÃ½pis pomocÃ­ `Write-Host` pÅ™Ã­liÅ¡ nevyplatÃ­, pro formÃ¡tovanÃ½ vÃ½pis proto pouze uvedeme nÃ¡zev promÄ›nnÃ©.

```ps1
Write-Host $hshtbl
# â†’ System.Collections.DictionaryEntry System.Collections.DictionaryEntry

$hshtbl
<# â†’
Name                           Value
----                           -----
abc                            def
0                              5
#>

# Pro nested hashtables se hodÃ­
$hshtbl | ConvertTo-Json -Depth 1
```

PomocÃ­ `ForEach-Object` iterujeme hashtable. NapÅ™. pÅ™es klÃ­Äe s vyuÅ¾itÃ­m `Keys` nebo pÅ™es dvojice s vyuÅ¾itÃ­m `GetEnumerator()`.

```ps1
$hshtbl.Keys | ForEach-Object {
    $key = $_
    $value = $hshtbl[$_]
}

$hshtbl.GetEnumerator() | ForEach-Object {
    $key = $_.Key
    $value = $_.Value
}
```

StejnÄ› jako u polÃ­ funguje u hashtables sÄÃ­tÃ¡nÃ­. Pro odebrÃ¡nÃ­ prvku slouÅ¾Ã­ metoda `Remove`.

```ps1
$hshtbl += @{"ghi"="jkl"}
$hshtbl.Remove("ghi")
```

Hashtables nemajÃ­ Å¾Ã¡dnÃ© internÃ­ poÅ™adÃ­. Pokud chceme pracovat s jejich seÅ™azenÃ½mi hodnotami, seÅ™adÃ­me jejich enumerÃ¡tor.

```ps1
$p.GetEnumerator() | Sort-Object -Property Key
$p.GetEnumerator() | Sort-Object -Property Value -Descending
```

#### Dictionary

Chceme-li v naÅ¡em asociativnÃ­m poli pevnÃ© datovÃ© typy, vypÅ¯jÄÃ­me si z frameworku .NET Dictionary.

```ps1
$dict = [System.Collections.Generic.Dictionary[string, int]]::New()
$dict["0"] = 0
$dict["1"]++
Write-Host $dict  # â†’ [0, 0] [1, 1]
```

### DalÅ¡Ã­ kolekce

* HashSet â€“ `[System.Collections.Generic.HashSet[ğ‘‡]]`
* SortedSet â€“ `[System.Collections.Generic.SortedSet[ğ‘‡]]`
* Queue â€“ `[System.Collections.Generic.Queue[ğ‘‡]]`
* Stack â€“ `[System.Collections.Generic.Stack[ğ‘‡]]`
* LinkedList â€“ `[System.Collections.Generic.LinkedList[ğ‘‡]]`

## OOP

### PSCustomObject

_PSCustomObject_ nÃ¡m umoÅ¾Åˆuje vytvÃ¡Å™et objekty na mÃ­ru. Na prvnÃ­ pohled mÅ¯Å¾e vypadat podobnÄ› jako _hashtable_, je ale mocnÄ›jÅ¡Ã­. VhodnÄ›jÅ¡Ã­ je napÅ™. v situaci, kdy chceme mÃ­t vÃ­ce objektÅ¯ stejnÃ©ho typu v kolekci. NamÃ­sto dvojic klÃ­Ä-hodnota mÃ¡ vlastnosti, kterÃ© nabÃ½vajÃ­ urÄitÃ½ch hodnot, a metody, kterÃ© s nimi mohou pracovat. (Pro plnohodnotnÄ›jÅ¡Ã­ OOP v PowerShellu je pak k dispozici jeÅ¡tÄ› _Class_.)

```ps1
# Deklarace je podobnÃ¡ hashtable
$album = [PSCustomObject]@{
    Name = "Katastrofalni selhani"
    Artist = "FilthwAre"
    NTracks = 7
}

# PÅ™Ã­stup pomocÃ­ teÄky
$album.NTracks = 8

# KompaktnÃ­ vÃ½pis, pokud pouÅ¾ijeme Write-Host; nebo tabulkovÃ½ vÃ½pis, pokud napÃ­Å¡eme pouze nÃ¡zev promÄ›nnÃ©
Write-Host $album  # â†’ @{Name=Katastrofalni selhani; Artist=FilthwAre; NTracks=8}

# Pro pÅ™idÃ¡nÃ­ vlastnosti je tÅ™eba pouÅ¾Ã­t Add-Member
$album.Year = 2025  # Error
$album | Add-Member -MemberType NoteProperty -Name "Year" -Value 2025

# OdebrÃ¡nÃ­ vlastnosti
$album.psobject.Properties.Remove("Year")

# ZÃ­skÃ¡nÃ­ seznamu vlastnostÃ­
$album | Get-Member -MemberType NoteProperty | Select-Object -ExpandProperty Name  # SeÅ™azeno abecednÄ›
$album.psobject.Properties.Name  # SeÅ™azenÃ­ odpovÃ­dÃ¡ poÅ™adÃ­ pÅ™i definici

# K vlastnostem lze pÅ™istupovat Å™etÄ›zcem, jehoÅ¾ hodnota je nÃ¡zvem vlastnosti
Write-Host $album."NTracks"  # â†’ 8

# DÃ­ky tomu lze iterovat dvojice vlastnost-hodnota
$album.psobject.Properties.Name | ForEach-Object {
    Write-Host "${_} = $($album.$_)"
}

# Objektu mÅ¯Å¾eme pÅ™idat vlastnÃ­ metodu; k vlastnostem pÅ™istupujeme pomocÃ­ $this
$album | Add-Member ScriptMethod -Name CustomToString -Value {
    param($delimiter)
    return "$($this.Artist) ${delimiter} $($this.Name)"
}
$album.CustomToString("::") # â†’ FilthwAre :: Katastrofalni selhani

# PSCustomObject je referenÄnÃ­ datovÃ½ typ, pro vytvoÅ™enÃ­ kopie tedy nepostaÄÃ­ pÅ™iÅ™azenÃ­ do dalÅ¡Ã­ promÄ›nnÃ©
# K dispozici je metoda pro vytvoÅ™enÃ­ shallow copy
$shallowCopy = $album.psobject.Copy()
```

* `Add-Member` pÅ™idÃ¡ k objektu vlastnÃ­ vlastnosti a metody
* `Compare-Object` porovnÃ¡ objekty
* `Get-Member` zÃ­skÃ¡ vlastnosti a metody z objektu
* `Get-Unique` vrÃ¡tÃ­ unikÃ¡tnÃ­ prvky ze __seÅ™azenÃ©__ kolekce
* `Group-Object` seskupÃ­ objekty podle spoleÄnÃ½ch hodnot urÄitÃ½ch vlastnostÃ­
* `Measure-Object` provede zÃ¡kladnÃ­ statistickou analÃ½zu nad objekty (zkoumÃ¡ ÄÃ­selnÃ© hodnoty a Å™etÄ›zce)
* `Select-Object` vybere konkrÃ©tnÃ­ vlastnosti objektÅ¯
* `Select-String` hledÃ¡ text, obdoba `grep`
* `Sort-Object` seÅ™adÃ­ objekty podle urÄitÃ© vlastnosti
* `Where-Object` vybere objekty podle hodnot jejich urÄitÃ½ch vlastnostÃ­

### Class

[MSLearn/about_Classes](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_classes?view=powershell-5.1)

### Enum

[MSLearn/about_Enum](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_enum?view=powershell-5.1)
